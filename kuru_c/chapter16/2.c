/* **構造体の引数**
**構造体でもポインタ変数**
student型へのポインタ変数を使用する例です。

#include <stdio.h>
#include <string.h>

typedef struct {
	int year; 学年
	int clas; クラス
	int number; 出席番号
	char name[64]; 名前
	double stature; 身長
	double weight; 体重
} student;

int main(void)
{
	student data;
	student *pdata;

	pdata = &data; 初期化
	(*pdata).year = 10; 通常変数モードへの切り替え
	strcpy((*pdata).name,"MARIO"); 通常変数モードへの切り替え

	return 0;
}

構造体の各要素は、宣言の時の順番通りに並んでおり、&演算子で求められるアドレスは、構造体の**始め**の要素のアドレスです。

構造体のポインタ変数の場合も、*記号で通常変数モードに切り替えることが出来ます。
ただし、.の方が優先されるので、かっこをつけて次のようにします。

(*構造体ポインタ変数名).要素名

ただ、(*)をつけるのは面倒なので、次の書き方で代用出来るようになっています。

構造体ポインタ変数名->要素名
->は、引き算と比較記号を組み合わせた記号です。

普通に渡すことが出来る構造体を、ポインタ変数として渡す理由の
1つ目は、普通のポインタ変数と同じく、**関数内で値を変更出来るようにするため**です。
関数内で値を変えると呼び出し元の変数の中身も**変わります**。

2つ目は、関数呼び出しの高速化のためです。
構造体を渡す時、その中身は全てコピーされます。
構造体の中に、大きな配列があれば、その中身までまるごとコピーされます。
これは、当然ながらそれなりに時間のかかる処理となります。
しかし、ポインタのアドレス値を渡すだけなら、ほとんど時間はかかりません。 */