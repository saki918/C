/* **メモリの仕組み**
電子部品の状態がオンならば1、オフならば0というように、それぞれの部品が、1であるか0であるかを記憶しています。
、例えるならば、超巨大な1列ロッカーのような構造です。

**CPUのビット数**
CPUが1回で扱うメモリの2進数での桁数が、ビット数なのです。

**32ビットのロッカー**
ロッカーを8個ずつにまとめて、8個を1単位として番号を割り当てています。
32ビットコンピュータでは、これに32ビットの範囲内で番号が割り当てられています。
32ビットの範囲内ということは、すなわち、2進数で、
00000000000000000000000000000000 ～ 11111111111111111111111111111111
の範囲内であり、10進数で約42億番までの8ビットの数値を扱うことが出来るのです。

**変数はメモリ上に存在する**
**全ての変数はメモリに作られており、そこでは、番号をつけて区別しているということをまずは頭に入れて下さい。**

**メモリ上の番号を表示する**
番号を調べるのは意外に簡単で、printf関数で**%p**指定子を使うだけです。ただし、変数名の前には、&をつける必要があります。
変数につけられた番号のことを、**アドレス**と呼んでいます。

#include <stdio.h>

int main(void)
{
	int i;
	printf("%p\n",&i);
	return 0;
}

**複数の変数の番号**
int型のサイズが4バイト。int型以外の変数もコンパイラ毎にサイズが異なっています。char型だけは、必ず1バイト

何故なら、この3つの変数は別々に使われる変数なので、バラバラの場所にあっても何も問題はないからです。

**配列の番号**
配列の場合には、先頭に&をつける必要はありません。ただし、配列の個々の要素は変数と同じ扱いなので、当然&をつけます。
&演算子を使うと、変数のアドレスを知ることが出来る

引数で関数に渡されるデータは、**全て数値**であるということです。引数で数値を渡す方式を、値渡しと呼ぶことがあります。
値渡し >>> 関数に単なる数値として情報を渡す方法。

**scanf関数で&をつける理由**
scanf関数は、キーボードからの入力を行い、変数に記憶する関数です。
関数には変数に記憶された値のコピーしか渡すことが出来ません。
これでは、変数に新たな値を記憶することが出来なくなってしまいます。
※変数の**値**を渡してしまうとその値しか使えなくなってしまうので、
アドレスを渡してあげることで、変数の中身を変更したりすることが可能なので融通がきく。

文字列を入力する時は、配列名の前に&をつけなかったことです。これは、配列名は配列の最初の要素のアドレスを表しています。
従って、配列名を渡せば、配列の場所がわかるため、&は不要です。

#include <stdio.h>

int main(void)
{
	char str[256];
	scanf("%s",&str[0]); 0番の要素のアドレス
	printf("%s\n",str);
	return 0;
}
このプログラムの実行結果は、次の通りになります。

MARIO キーボードから入力した文字列
MARIO
このプログラムは、配列名の代わりに、要素0番のアドレスを指定しただけです。
どちらも全く同じことを意味しているので、問題ありません。
更に、次のようにすれば、配列の途中から入力させることすら出来ます。

#include <stdio.h>

int main(void)
{
	char str[256] = "DRAGON";
	scanf("%s",&str[6]); 6番の要素のアドレス
	printf("%s\n",str);
	return 0;
}
このプログラムの実行結果は、次の通りになります。

QUEST キーボードから入力した文字列
DRAGONQUEST */