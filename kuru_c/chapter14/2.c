/* **文字列のコピー**
strcpy関数を使うと、文字列のコピーを行うことが出来ます。
strcpy関数を使うには、**string.h** を #include する必要があります。

strcpy(コピー先文字列配列名,コピー元文字列配列名);

先頭から指定された文字数だけをコピーするstrncpy関数もあります。

strncpy(コピー先文字列配列名,コピー元文字列配列名,コピーする文字数);
コピーされた文字列の最後にEOSが入っていないことがあります。
そのまま表示させると延々と表示され続けるので、**必ずEOS**を付けます。

**文字列の連結**
配列に記憶された文字列を連結する場合には、配列名を並べても駄目です。その場合はstrcat関数を使います。strcat関数の使い方は次の通りです。strcat関数を使うには、**string.h** を #include する必要があります。

strcat(元の文字列が記憶された配列,追加する文字列の記憶された配列);

この関数を使う時に注意してほしいのは、元の文字列が記憶された配列は、元の文字列+追加する文字列だけの大きさが必要になることです。

**究極の文字列合成関数**
sprintf関数は、printf関数と同じ機能を持った関数ですが、sprintf関数の場合、結果を配列の中に記憶します。
printf関数の様々な機能を自由に取り扱うことが出来るのです。

sprintf(結果を記憶する配列,書式文字列,各種変数・・・);
次のプログラムは、sprintf関数を使う例です。

#include <stdio.h>

int main(void)
{
	char str[16];
	char str1[12] = "DRAGON";
	char str2[] = "QUEST";
	int i = 3;
	sprintf(str,"%s%s%d\n",str1,str2,i);
  printf関数は文字列を表示する関数なので、わざわざ %s指定子を使わなくても表示できる
	printf(str);
	return 0;
}
このプログラムの実行結果は次の通りになります。

DRAGONQUEST3

**文字列の入力**
scanf("%s", str); の問題点
1つ目は、配列の要素数よりも多く入力すると暴走してしまうことです。これが、第6章でも説明した入力ミスの恐怖なのです。
この問題を解決するには、文字配列の要素数を%とsの間で指定します。
例えば、要素数が32の場合は**%32s**と指定すると、それ以上の文字は切り捨てられます。

2つ目は、この方法では、スペースを入力できないことです。これは、スペースが区切り記号として認識されるためです。

**文字数を数える**
文字列の文字数を数えるstrlen関数が用意されています。strlen関数を使うには、**string.h** を #include する必要があります。

変数 = strlen(文字配列);

**文字列の比較**
文字配列の内容が同じかを比較する場合、次のようなプログラムを考えると思います。

str1 == str2;

しかし、文字配列同士の比較では==演算子を使うことは出来ません。
この例では配列が全く同じ(同じ**メモリ**を使う)配列なのかを比較しているのであり、
**配列の中身が同じかどうかを比較しているわけではない**ためです。
文字列の比較では**EOSまでが同じ**でなければならないため、比較元の文字数よりも1文字大きく比較しています。

文字列を比較するstrcmp関数が用意されています。strcmp関数を使うには、**string.h** を #include する必要があります。

変数 = strcmp(文字配列1,文字配列2);

練習問題 3-1
名字と名前を別々に入力させて、それを結合して表示するプログラムを作成せよ。 */

#include <stdio.h>
// strcat を用いるために記述
#include <string.h>

int main(void)
{
  char surname[40];
  char name[15];
  printf("名字を入力してください。：");
  scanf("%15s", surname);
  printf("名前を入力してください。：");
  scanf("%15s", name);
  // surname に name の文字列を足して格納 ※第一引数(surname)には第二引数(name)を足した数値より多い数値を設定する。
  strcat(surname, name);
  printf("姓名：%s\n", surname);
  return 0;
}